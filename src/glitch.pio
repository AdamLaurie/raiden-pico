; GPIO RISING edge detection (0->1) - ONE-SHOT trigger with debouncing
; Debounce: wait for LOW, add delay, verify LOW, then wait for HIGH
.program gpio_edge_detect_rising
start:
    wait 0 pin 0        ; Wait for trigger pin to be LOW
    nop [31]            ; Debounce delay: 32 cycles @ 150MHz = ~213ns
    nop [31]            ; Additional 32 cycles = ~426ns total
    nop [31]            ; Additional 32 cycles = ~639ns total
    wait 0 pin 0        ; Verify pin is still LOW (stable)
    wait 1 pin 0        ; Wait for RISING edge (LOW->HIGH)
    irq set 0           ; Trigger glitch via IRQ
.wrap_target
    jmp 0               ; Halt: infinite loop, one-shot trigger
.wrap

; GPIO FALLING edge detection (1->0) - ONE-SHOT trigger with debouncing
; Debounce: wait for HIGH, add delay, verify HIGH, then wait for LOW
.program gpio_edge_detect_falling
start:
    wait 1 pin 0        ; Wait for trigger pin to be HIGH
    nop [31]            ; Debounce delay: 32 cycles @ 150MHz = ~213ns
    nop [31]            ; Additional 32 cycles = ~426ns total
    nop [31]            ; Additional 32 cycles = ~639ns total
    wait 1 pin 0        ; Verify pin is still HIGH (stable)
    wait 0 pin 0        ; Wait for FALLING edge (HIGH->LOW)
    irq set 0           ; Trigger glitch via IRQ
.wrap_target
    jmp 0               ; Halt: infinite loop, one-shot trigger
.wrap

; UART RX with byte matching - NO autopush, direct ISR comparison
; SM clock = 8× baud rate, IN pin 0 = GP28 (jumpered from GP5)
; RP2350B BUG: PIO and UART peripheral cannot share GPIO - requires GP5→GP28 jumper
; Shift right to receive LSB-first UART data
.program uart_rx_decoder
    pull block          ; Get trigger byte from FIFO
    mov y, osr          ; Store trigger byte in Y

.wrap_target
start:
    mov isr, null       ; Clear ISR before receiving new byte
    wait 0 pin 0        ; Wait for start bit
    set x, 7 [10]       ; Preload bit counter, delay to eye of first data bit
bitloop:
    in pins, 1          ; Shift data bit into ISR (right shift)
    jmp x-- bitloop [6] ; Loop 8 times, 8 cycles each

    ; Now ISR contains the received byte (in bits [24:31] after right shift)
    ; Move ISR to X for comparison
    mov x, isr          ; X = received byte (bits [24:31] = data, bits [0:23] = 0)
    jmp x!=y start      ; If not equal to trigger byte, loop back

    ; Match! Trigger the glitch
    irq set 0
.wrap

; Pulse generator with IRQ trigger and COUNT loop
; Waits for IRQ 0, then pulls: PAUSE, COUNT, WIDTH, GAP
; Loops COUNT times emitting WIDTH (HIGH) and GAP (LOW) pulses
; SET pins controls PIN_GLITCH_OUT (GP2)
; SIDE pins controls PIN_GLITCH_OUT_INV (GP11) - inverted in hardware
.program pulse_generator
.side_set 1
.wrap_target
start:
    wait 1 irq 0        side 0  ; Wait for IRQ 0, both pins idle LOW (side inverted to HIGH)
    pull block          side 0  ; Get PAUSE value
    out x, 32           side 0  ; Move to X
pause_loop:
    jmp x-- pause_loop  side 0  ; Wait for PAUSE cycles

    pull block          side 0  ; Get COUNT value
    out y, 32           side 0  ; COUNT in Y (outer loop counter)
    pull block          side 0  ; Get WIDTH value
    mov isr, osr        side 0  ; Save WIDTH to ISR (preserved across loop)
    pull block          side 0  ; Get GAP value
                                ; GAP stays in OSR (preserved across loop)

pulse_loop:
    ; Emit WIDTH pulse (HIGH on both pins, hardware inverts one)
    mov x, isr          side 1  ; Load WIDTH from ISR
    set pins, 1         side 1  ; Set output HIGH on both (hardware inverts side pin)
width_loop:
    jmp x-- width_loop  side 1  ; Wait for WIDTH cycles

    ; Emit GAP (LOW on both pins, hardware inverts one)
    mov x, osr          side 0  ; Load GAP from OSR
    set pins, 0         side 0  ; Set output LOW on both (hardware inverts side pin)
gap_loop:
    jmp x-- gap_loop    side 0  ; Wait for GAP cycles

    jmp y-- pulse_loop  side 0  ; Loop COUNT times
.wrap                           ; Wrap back to start to wait for next trigger

; Flag output - outputs 4-bit flags to GPIO
.program flag_output
.wrap_target
    pull block          ; Get all 4 flags as 32-bit word
    out pins, 4         ; Output lower 4 bits to pins
.wrap

; Clock generator with delay for precise timing
.program clock_generator_delay
    pull block          ; Get half-period cycle count
    mov y, osr          ; Save to Y for reuse
.wrap_target
    set pins, 1         ; Set HIGH
    mov x, y            ; Load half-period count
high:
    jmp x-- high        ; Delay for half period
    set pins, 0         ; Set LOW
    mov x, y            ; Load half-period count
low:
    jmp x-- low         ; Delay for half period
.wrap

; Clock generator with glitch boost
; Y = normal_half_period, ISR = fast_half_period (set by C via pio_sm_exec)
; For boost: C pushes [count, normal_period] and triggers via IRQ or special mechanism
.program clock_generator_with_boost
.wrap_target
clock_loop:
    ; Normal clock cycle (Y = half_period, ISR = fast_half_period)
    set pins, 1
    mov x, y
h:
    jmp x-- h
    set pins, 0
    mov x, y
l:
    jmp x-- l
.wrap

; Boost section - entered by jumping here from C using pio_sm_exec
; Not used in normal wrap loop to avoid FIFO polling issues
public entry_boost:
    ; OSR already has count (loaded by C)
    mov x, osr

boost_loop:
    ; Fast HIGH
    set pins, 1
    mov osr, isr
    mov y, osr
fh:
    jmp y-- fh

    ; Fast LOW
    set pins, 0
    mov osr, isr
    mov y, osr
fl:
    jmp y-- fl

    jmp x-- boost_loop

    ; Restore Y = normal_period (pushed by C) and return to normal clock
    pull block
    mov y, osr
public entry_return:
    ; Jump back to start of normal clock loop
    ; Need to use a fixed offset - wrap_target is at offset 0 of this program
    jmp clock_loop

; Simple clock generator
.program clock_generator
.wrap_target
    set pins, 1         ; Set output HIGH
    set pins, 0         ; Set output LOW
.wrap

; IRQ trigger helper - single instruction that sets IRQ 0 and wraps
; This allows CPU to trigger via pio_sm_exec without instruction overhead
.program irq_trigger
.wrap_target
    irq set 0           ; Set IRQ 0 and immediately wrap
.wrap
