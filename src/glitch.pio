; GPIO RISING edge detection (0->1) - ONE-SHOT trigger with debouncing
; Debounce: wait for LOW, add delay, verify LOW, then wait for HIGH
; SET pin pulses GP12 (GLITCH_FIRED) to signal PIO1 clock boost
.program gpio_edge_detect_rising
start:
    wait 0 pin 0        ; Wait for trigger pin to be LOW
    nop [31]            ; Debounce delay: 32 cycles @ 150MHz = ~213ns
    nop [31]            ; Additional 32 cycles = ~426ns total
    nop [31]            ; Additional 32 cycles = ~639ns total
    wait 0 pin 0        ; Verify pin is still LOW (stable)
    wait 1 pin 0        ; Wait for RISING edge (LOW->HIGH)
    irq set 0           ; Trigger glitch via IRQ
    set pins, 1         ; Pulse GP12 HIGH (GLITCH_FIRED signal for clock boost)
.wrap_target
    jmp 0               ; Halt: infinite loop, one-shot trigger
.wrap

; GPIO FALLING edge detection (1->0) - ONE-SHOT trigger with debouncing
; Debounce: wait for HIGH, add delay, verify HIGH, then wait for LOW
; SET pin pulses GP12 (GLITCH_FIRED) to signal PIO1 clock boost
.program gpio_edge_detect_falling
start:
    wait 1 pin 0        ; Wait for trigger pin to be HIGH
    nop [31]            ; Debounce delay: 32 cycles @ 150MHz = ~213ns
    nop [31]            ; Additional 32 cycles = ~426ns total
    nop [31]            ; Additional 32 cycles = ~639ns total
    wait 1 pin 0        ; Verify pin is still HIGH (stable)
    wait 0 pin 0        ; Wait for FALLING edge (HIGH->LOW)
    irq set 0           ; Trigger glitch via IRQ
    set pins, 1         ; Pulse GP12 HIGH (GLITCH_FIRED signal for clock boost)
.wrap_target
    jmp 0               ; Halt: infinite loop, one-shot trigger
.wrap

; UART RX with byte matching - NO autopush, direct ISR comparison
; SM clock = 8× baud rate, IN pin 0 = GP28 (jumpered from GP5)
; RP2350B BUG: PIO and UART peripheral cannot share GPIO - requires GP5→GP28 jumper
; Shift right to receive LSB-first UART data
; SET pin pulses GP9 (boost semaphore) to signal PIO1 clock boost
.program uart_rx_decoder
    pull block          ; Get trigger byte from FIFO
    mov y, osr          ; Store trigger byte in Y

.wrap_target
start:
    mov isr, null       ; Clear ISR before receiving new byte
    wait 0 pin 0        ; Wait for start bit
    set x, 7 [10]       ; Preload bit counter, delay to eye of first data bit
bitloop:
    in pins, 1          ; Shift data bit into ISR (right shift)
    jmp x-- bitloop [6] ; Loop 8 times, 8 cycles each

    ; Now ISR contains the received byte (in bits [24:31] after right shift)
    ; Move ISR to X for comparison
    mov x, isr          ; X = received byte (bits [24:31] = data, bits [0:23] = 0)
    jmp x!=y start      ; If not equal to trigger byte, loop back

    ; Match! Trigger the glitch
    irq set 0           ; Trigger glitch via IRQ
    set pins, 1         ; Pulse GP9 HIGH
    nop [31]            ; Hold for 32 cycles
    nop [31]            ; Hold for 32 cycles
    nop [31]            ; Hold for 32 cycles (total ~100 cycles = 667ns)
    set pins, 0         ; Return GP9 LOW
.wrap

; Pulse generator with IRQ trigger and COUNT loop
; Waits for IRQ 0, then pulls: PAUSE, COUNT, WIDTH, GAP
; Loops COUNT times emitting WIDTH (HIGH) and GAP (LOW) pulses
; SET pins controls PIN_GLITCH_OUT (GP2)
; SIDE pins controls PIN_GLITCH_OUT_INV (GP11) - inverted in hardware
.program pulse_generator
.side_set 1
.wrap_target
start:
    wait 1 irq 0        side 0  ; Wait for IRQ 0, both pins idle LOW (side inverted to HIGH)
    pull block          side 0  ; Get PAUSE value
    out x, 32           side 0  ; Move to X
pause_loop:
    jmp x-- pause_loop  side 0  ; Wait for PAUSE cycles

    pull block          side 0  ; Get COUNT value
    out y, 32           side 0  ; COUNT in Y (outer loop counter)
    pull block          side 0  ; Get WIDTH value
    mov isr, osr        side 0  ; Save WIDTH to ISR (preserved across loop)
    pull block          side 0  ; Get GAP value
                                ; GAP stays in OSR (preserved across loop)

pulse_loop:
    ; Emit WIDTH pulse (HIGH on both pins, hardware inverts one)
    mov x, isr          side 1  ; Load WIDTH from ISR
    set pins, 1         side 1  ; Set output HIGH on both (hardware inverts side pin)
width_loop:
    jmp x-- width_loop  side 1  ; Wait for WIDTH cycles

    ; Emit GAP (LOW on both pins, hardware inverts one)
    mov x, osr          side 0  ; Load GAP from OSR
    set pins, 0         side 0  ; Set output LOW on both (hardware inverts side pin)
gap_loop:
    jmp x-- gap_loop    side 0  ; Wait for GAP cycles

    jmp y-- pulse_loop  side 0  ; Loop COUNT times
.wrap                           ; Wrap back to start to wait for next trigger

; Flag output - outputs 4-bit flags to GPIO
.program flag_output
.wrap_target
    pull block          ; Get all 4 flags as 32-bit word
    out pins, 4         ; Output lower 4 bits to pins
.wrap

; Clock generator with delay for precise timing
.program clock_generator_delay
    pull block          ; Get half-period cycle count
    mov y, osr          ; Save to Y for reuse
.wrap_target
    set pins, 1         ; Set HIGH
    mov x, y            ; Load half-period count
high:
    jmp x-- high        ; Delay for half period
    set pins, 0         ; Set LOW
    mov x, y            ; Load half-period count
low:
    jmp x-- low         ; Delay for half period
.wrap

; Clock generator with GLITCH_FIRED boost
; Y = normal_half_period, ISR = fast_half_period (set by C via pio_sm_exec)
; JMP pin = GP12 (GLITCH_FIRED from PIO0 - set HIGH on glitch, cleared on next ARM)
; Note: GLITCH_FIRED can only be HIGH when armed, so no need to check ARMED separately
.program clock_generator_with_boost
.wrap_target
normal_clock:
    ; Normal clock cycle (Y = normal_half_period)
    set pins, 1             ; HIGH
    mov x, y
high_normal:
    jmp x-- high_normal

    set pins, 0             ; LOW
    mov x, y
low_normal:
    jmp x-- low_normal

    ; Check if GLITCH_FIRED (GP12 HIGH via JMP pin)
    jmp pin boost_entry     ; If glitch fired, trigger boost
    jmp normal_clock        ; Otherwise, continue normal clock

boost_entry:
    ; Pull boost count from FIFO (pre-loaded by CPU during clock setup)
    pull noblock            ; Non-blocking pull - if empty, OSR unchanged
    mov x, osr              ; X = boost count (outer loop)

boost_loop:
    ; Fast HIGH (ISR = fast_half_period)
    set pins, 1
    mov osr, isr            ; Copy fast period from ISR to OSR
    mov y, osr              ; Move to Y for countdown
high_boost:
    jmp y-- high_boost

    ; Fast LOW
    set pins, 0
    mov osr, isr
    mov y, osr
low_boost:
    jmp y-- low_boost

    jmp x-- boost_loop      ; Repeat COUNT times

    ; Restore normal period to Y
    pull noblock
    mov y, osr              ; Restore normal_half_period
.wrap                       ; Resume normal clock

; Simple clock generator
.program clock_generator
.wrap_target
    set pins, 1         ; Set output HIGH
    set pins, 0         ; Set output LOW
.wrap

; IRQ trigger helper - sets IRQ 0 and pulses GP9 for clock boost
; This allows CPU to trigger via pio_sm_exec without instruction overhead
; SET pin should be configured to GP9 (boost semaphore)
.program irq_trigger
.wrap_target
    irq set 0           ; Trigger glitch via IRQ
    set pins, 1         ; Pulse GP9 HIGH
    nop [31]            ; Hold for 32 cycles
    nop [31]            ; Hold for 32 cycles
    nop [31]            ; Hold for 32 cycles (total ~100 cycles = 667ns)
    set pins, 0         ; Return GP9 LOW
.wrap
